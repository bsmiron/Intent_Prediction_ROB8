def matlabcontrolV3():
  # Global parameters:
  global speed_ms = 0.250
  global speed_rads = 0.750
  global accel_mss = 1.200
  global accel_radss = 1.200
  global blend_radius_m = 0.001
  global ref_frame = p[0, 0, 0, 0, 0, 0]

  #--------------------------
  # Add any default subprograms here
  # For example, to drive a gripper as a program call:
  # def Gripper_Open():
  #   ...
  # end
  #
  # Example to drive a spray gun:
  def SprayOn(value):
    # use the value as an output:
    DO_SPRAY = 5
    if value == 0:
      set_standard_digital_out(DO_SPRAY, False)
    else:
      set_standard_digital_out(DO_SPRAY, True)
    end
  end

  # Example to drive an extruder:
  def Extruder(value):
    # use the value as an output:
    if value < 0:
      # stop extruder
    else:
      # start extruder
    end
  end

  # Example to move an external axis
  def MoveAxis(value):
    # use the value as an output:
    DO_AXIS_1 = 1
    DI_AXIS_1 = 1
    if value <= 0:
      set_standard_digital_out(DO_AXIS_1, False)

      # Wait for digital input to change state
      #while (get_standard_digital_in(DI_AXIS_1) != False):
      #  sync()
      #end
    else:
      set_standard_digital_out(DO_AXIS_1, True)

      # Wait for digital input to change state
      #while (get_standard_digital_in(DI_AXIS_1) != True):
      #  sync()
      #end
    end
  end
  #--------------------------

  # Subprogram StoreForwardKinematics
  def StoreForwardKinematics():
    pose_1 = get_forward_kin()
    global pointer = 0 #TODO: does this have to be global?
    varmsg("pointer", pointer)
    #textmsg("pointer ",pointer)
    while (pointer < receive_data[0]):
      Move_To_Pos[pointer] = pose_1[pointer]
      global pointer = pointer + 1
      varmsg("pointer", pointer)
      #textmsg("pointer ",pointer)
    end
  end

  def StoreActualJointPositions():
    joint_positions = get_actual_joint_positions()
    global pointer = 0 #TODO: does this have to be global?
    varmsg("pointer", pointer)
    #textmsg("pointer ",pointer)
    while (pointer < receive_data[0]):
      Move_To_Joint_Pos[pointer] = joint_positions[pointer]
      global pointer = pointer + 1
      varmsg("pointer", pointer)
      #textmsg("pointer ",pointer)
    end
  end

  # Subprogram SendForwardKinematics
  def SendForwardKinematics():
    pose_1 = get_forward_kin()
    textmsg("send forward kin to socket ", pose_1)
    socket_send_string(pose_1)
  end

  # Subprogram ReadAndStorePoseFromSocket
  def ReadAndStorePoseFromSocket():
    receive_data = socket_read_ascii_float(6)
    textmsg("Set pose:", receive_data)
    if (receive_data[0] != 6):
      socket_send_string("0")
    else:
      socket_send_string("1")
      global pointer = 0 #TODO: does this have to be global?
      varmsg("pointer", pointer)
      #varmsg("pointer", pointer)
      while (pointer < receive_data[0]):
        Move_To_Pos[pointer] = receive_data[pointer + 1]
        global pointer = pointer + 1
        #varmsg("pointer"pointer)
        varmsg("pointer ", pointer)
      end

      move_type = 0

      global task = [0, 0]
      #varmsg("task"task)
      varmsg("task", task)
    end
  end

  # Subprogram SendActualJointPositionToSocket
  def SendActualJointPositionToSocket():
    joint_positions = get_actual_joint_positions()
    textmsg("send actual pos to socket ", joint_positions)
    socket_send_string(joint_positions)
  end

  # Subprogram to read and store joint prostions form socket 
  def ReadAndStoreJointPositionsFormSocket():
    receive_data = socket_read_ascii_float(6)
    textmsg("Set joint pos:", receive_data)
    if (receive_data[0] != 6):
      socket_send_string("0")
    else:
      socket_send_string("1")
      global pointer = 0
      varmsg("pointer", pointer)
      #varmsg("pointer", pointer)
      
      while (pointer < receive_data[0]):
        Move_To_Joint_Pos[pointer] = receive_data[pointer + 1]
        global pointer = pointer + 1
        #varmsg("pointer"pointer)
        varmsg("pointer ", pointer)
      end

      move_type = 1

      global task = [0, 0]
      varmsg("task", task)
    end
  end

  # Main program:
  # Program generated by RoboDK v5.3.0 for UR5 on 05/10/2021 14:40:40
  # Using nominal kinematics.
  set_analog_inputrange(0, 0)
  set_analog_inputrange(1, 0)
  set_analog_inputrange(2, 0)
  set_analog_inputrange(3, 0)
  set_analog_outputdomain(0, 0)
  set_analog_outputdomain(1, 0)
  set_tool_voltage(0)
  set_runstate_outputs([])
  set_payload(0.0)
  set_gravity([0.0, 0.0, 9.82])
  flag_N = 1
  varmsg("flag_N", flag_N)
  i_var_1 = 1
  varmsg("i_var_1", i_var_1)
  #TODO: remove MTool_pos variable
  MTool_pos = p[0, 0, 0, 0, 0, 0]
  varmsg("MTool_pos", MTool_pos)
  #TODO: remove Base variable
  Base = p[0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
  varmsg("Base", Base)
  #TODO: remove Tool variable
  Tool = get_forward_kin()
  varmsg("Tool", Tool)
  
  #Store the incoming data from the socket
  global receive_data = [6, 0, 0, 0, 0, 0, 0]
  varmsg("receive_data", receive_data)
  
  #Store the end effector (Target) position as a target-pose
  global Move_To_Pos = p[0, 0, 0, 0, 0, 0]
  varmsg("Move_To_Pos", Move_To_Pos)
  
  #Store the joint positions 
  global Move_To_Joint_Pos = [0, 0, 0, 0, 0, 0]
  
  StoreForwardKinematics()
  StoreActualJointPositions()
  socket_open("192.168.0.100", 30006)
  
  global task = [0, 0]
  varmsg("task", task)
  global coop = 0
  varmsg("coop", coop)

  # Variable to decide on wheter to use joint-position or target-position
  # 0 -> use target-position (default)
  # 1 -> use joint position
  # The idea is that this value will change after a command to read a position type
  # was made. See: ReadAndStoreJointPositionsFormSocket() and ReadAndStorePoseFromSocket()
  global move_type = 0
  
  thread Thread_1():
    while True:
      if (coop == 1):
        while (coop == 1):
          thread Force_properties_calculation_thread_31():
            while (True):
              force_mode(p[0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [1, 1, 1, 1, 1, 1], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0], 2, [0.15, 0.15, 0.15, 1.0471975511965976, 1.0471975511965976, 1.0471975511965976])
              sync()
            end
          end
          global thread_handler_31 = run Force_properties_calculation_thread_31()
          sleep(0.01)
          kill thread_handler_31
          end_force_mode()
        end
        global coop = 0
        varmsg("coop", coop)
        StoreForwardKinematics()
      else:
        # Decide what kind of movement to make.
        if (move_type == 0):
          #textmsg("movel: ", Move_To_Joint_Pos)
          movel(Move_To_Pos, a = 0.2, v = 0.2, r = 0)
        else:
          #textmsg("movej: ", Move_To_Joint_Pos)
          movej(Move_To_Joint_Pos, a=1.4, v=1.05, t=0, r=0)
        end
        sleep(0.01)
      end
    end
  end
  
  threadId_Thread_1 = run Thread_1()
  
  while (True):
    task = socket_read_ascii_float(1)
    textmsg("task", task)
    if (task[1] == 2):
      SendForwardKinematics()
      global task = [0, 0]
      #varmsg("task"task)
      varmsg("task", task)
      textmsg("task", task)
    
    elif (task[1] == 3):
        global coop = 1
        #varmsg("coop"coop)
        varmsg("coop", coop)
        socket_send_string("1")
        global task = [0, 0]
        #varmsg("task"task)
        varmsg("task", task)
    
    elif (task[1] == 4):
      global coop = 0
      #varmsg("coop"coop)
      varmsg("coop", coop)
      socket_send_string("1")
      global task = [0, 0]
      #varmsg("task"task)
      varmsg("task", task)
    
    elif (task[1] == 1):
        ReadAndStorePoseFromSocket()
    
    elif (task[1] == 7):
      SendActualJointPositionToSocket()
    elif (task[1] == 8):
      ReadAndStoreJointPositionsFormSocket()
    else:
      #Do nothing, 
    end
    sleep(0.010)
  end
  # End of main program
end

matlabcontrolV3()